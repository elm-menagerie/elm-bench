#!/bin/sh
':' // ; cat "$0" | node --input-type=module - "$@" ; exit $?

// Copyright (c) 2024 The Lispark s.r.o. - All Rights Reserved
// Written by Martin Janiczek <martin@janiczek.cz>
// You're authorized to use this code on an unlimited number of machines.
// You're not authorized to distribute or sell this code to other people.

/*
elm-bench
---------
A small CLI utility for easy benchmarking of Elm code.

Dependencies: elm, node

Priority:
TODO: Compare across Git revisions

TODO: specify extra imports for the -f mode?
TODO: check the Debug.toString representation of the versions is the same, and show a warning if it's not
TODO: use us, ms, s when it gets too big
TODO: allow specifying the path to the Elm compiler
TODO: be robust against arbitrary paths
TODO: stop spinner before each error message
*/

import { parseArgs, promisify } from "node:util";
import fs from "node:fs/promises";
import path from "node:path";
import os from "node:os";
import * as childProcess from "node:child_process";

const exec = promisify(childProcess.exec);

const semverGt = (v1, v2) => {
  const parse = (v) => v.split(".").map(Number);
  const [major1, minor1, patch1] = parse(v1);
  const [major2, minor2, patch2] = parse(v2);

  if (major1 !== major2) return major1 > major2;
  if (minor1 !== minor2) return minor1 > minor2;
  return patch1 > patch2;
};

const green = (str) => `\x1b[32m${str}\x1b[0m`;
const blue = (str) => `\x1b[34m${str}\x1b[0m`;
const red = (str) => `\x1b[31m${str}\x1b[0m`;
const dim = (str) => `\x1b[2m${str}\x1b[0m`;
const bold = (str) => `\x1b[1m${str}\x1b[0m`;

function startSpinner() {
  const characters = [ "⠀", "⠁", "⠂", "⠃", "⠄", "⠅", "⠆", "⠇", "⠈", "⠉", "⠊", "⠋", "⠌", "⠍", "⠎", "⠏", "⠐", "⠑", "⠒", "⠓", "⠔", "⠕", "⠖", "⠗", "⠘", "⠙", "⠚", "⠛", "⠜", "⠝", "⠞", "⠟", "⠠", "⠡", "⠢", "⠣", "⠤", "⠥", "⠦", "⠧", "⠨", "⠩", "⠪", "⠫", "⠬", "⠭", "⠮", "⠯", "⠰", "⠱", "⠲", "⠳", "⠴", "⠵", "⠶", "⠷", "⠸", "⠹", "⠺", "⠻", "⠼", "⠽", "⠾", "⠿", "⡀", "⡁", "⡂", "⡃", "⡄", "⡅", "⡆", "⡇", "⡈", "⡉", "⡊", "⡋", "⡌", "⡍", "⡎", "⡏", "⡐", "⡑", "⡒", "⡓", "⡔", "⡕", "⡖", "⡗", "⡘", "⡙", "⡚", "⡛", "⡜", "⡝", "⡞", "⡟", "⡠", "⡡", "⡢", "⡣", "⡤", "⡥", "⡦", "⡧", "⡨", "⡩", "⡪", "⡫", "⡬", "⡭", "⡮", "⡯", "⡰", "⡱", "⡲", "⡳", "⡴", "⡵", "⡶", "⡷", "⡸", "⡹", "⡺", "⡻", "⡼", "⡽", "⡾", "⡿", "⢀", "⢁", "⢂", "⢃", "⢄", "⢅", "⢆", "⢇", "⢈", "⢉", "⢊", "⢋", "⢌", "⢍", "⢎", "⢏", "⢐", "⢑", "⢒", "⢓", "⢔", "⢕", "⢖", "⢗", "⢘", "⢙", "⢚", "⢛", "⢜", "⢝", "⢞", "⢟", "⢠", "⢡", "⢢", "⢣", "⢤", "⢥", "⢦", "⢧", "⢨", "⢩", "⢪", "⢫", "⢬", "⢭", "⢮", "⢯", "⢰", "⢱", "⢲", "⢳", "⢴", "⢵", "⢶", "⢷", "⢸", "⢹", "⢺", "⢻", "⢼", "⢽", "⢾", "⢿", "⣀", "⣁", "⣂", "⣃", "⣄", "⣅", "⣆", "⣇", "⣈", "⣉", "⣊", "⣋", "⣌", "⣍", "⣎", "⣏", "⣐", "⣑", "⣒", "⣓", "⣔", "⣕", "⣖", "⣗", "⣘", "⣙", "⣚", "⣛", "⣜", "⣝", "⣞", "⣟", "⣠", "⣡", "⣢", "⣣", "⣤", "⣥", "⣦", "⣧", "⣨", "⣩", "⣪", "⣫", "⣬", "⣭", "⣮", "⣯", "⣰", "⣱", "⣲", "⣳", "⣴", "⣵", "⣶", "⣷", "⣸", "⣹", "⣺", "⣻", "⣼", "⣽", "⣾", "⣿" ];
  const cursorEsc = {
    hide: "\u001B[?25l",
    show: "\u001B[?25h",
  };
  process.stdout.write(cursorEsc.hide);

  let i = 0;
  const timer = setInterval(function () {
    process.stdout.write("\r" + blue(characters[i++]));
    i = i >= characters.length ? 0 : i;
  }, 100);

  return () => {
    clearInterval(timer);
    process.stdout.write("\r");
    process.stdout.write(cursorEsc.show);
  };
}

function usage() {
  console.error(`
${dim("Usage:")}

${dim("-f/--function mode:")}
  This mode benchmarks and compares multiple functions in the same Elm project.
  The project root is taken to be the current working directory.
  All functions will take the same set of arguments.
  Provide one or more -f flags with qualified function names:

    ${bold("elm-bench")} ${dim("[")}-f ${blue("QUALIFIED_FUNCTION")}${dim("]+")} ${dim("[")}${blue("ARG")}${dim("]+")}

    elm-bench ${dim("-f")} Foobar.run ${dim("-f")} Foobar.Optimized.run 1024
    elm-bench ${dim("-f")} Main.removeOld ${dim("-f")} Main.removeNew 42 "List.range 0 1000"

${dim("-v/--version mode:")}
  This mode benchmarks and compares the same function across multiple Elm projects.
  The projects are expected to be applications with a Main.elm file that exposes the function.
  All functions will take the same set of arguments.

    ${bold("elm-bench")} ${dim("[")}-v ${blue("VERSION_DIR")}${dim("]+")} ${blue("FUNCTION")} ${dim("[")}${blue("ARG")}${dim("]+")}

    elm-bench ${dim("-v")} ./old ${dim("-v")} ./new remove 42 "List.range 0 1000"
    elm-bench ${dim("-v")} ./old ${dim("-v")} ./new scenario "()"

${dim("Flags:")}
  -h, --help      Show this help message
  -k, --keep      Keep benchmark code in a temporary directory and print its path
  -j, --json      Print results in JSON format, minimize verbosity
`);
}

const mainJsCode = `const {Elm} = require('./elm.js');

const app = Elm.Benchmarks.init();

app.ports.sendOutput.subscribe((output) => {
    console.log(JSON.stringify(output, null, 2));
});`;

const runnerElmJsonCode = `{
    "type": "application",
    "source-directories": [
        "src"
    ],
    "elm-version": "0.19.1",
    "dependencies": {
        "direct": {
            "Janiczek/elm-benchmark-cli-runner": "1.0.0",
            "elm/core": "1.0.5",
            "elm-explorations/benchmark": "1.0.2",
            "lue-bird/elm-alternative-benchmark-runner": "1.0.0"
        },
        "indirect": {
            "BrianHicks/elm-trend": "2.1.3",
            "avh4/elm-color": "1.0.0",
            "elm/browser": "1.0.2",
            "elm/html": "1.0.0",
            "elm/json": "1.1.3",
            "elm/regex": "1.0.0",
            "elm/time": "1.0.0",
            "elm/url": "1.0.0",
            "elm/virtual-dom": "1.0.3",
            "mdgriffith/elm-ui": "1.1.8",
            "mdgriffith/style-elements": "5.0.2",
            "miniBill/elm-ui-with-context": "1.1.0",
            "robinheghan/murmur3": "1.0.0"
        }
    },
    "test-dependencies": {
        "direct": {},
        "indirect": {}
    }
}`;

// Parse arguments

const { values, positionals } = parseArgs({
  options: {
    help: {
      type: "boolean",
      short: "h",
      multiple: false,
    },
    keep: {
      type: "boolean",
      short: "k",
      multiple: false,
    },
    json: {
      type: "boolean",
      short: "j",
      multiple: false,
    },
    version: {
      type: "string",
      short: "v",
      multiple: true,
    },
    function: {
      type: "string",
      short: "f",
      multiple: true,
    },
  },
  allowPositionals: true,
});

const keep = "keep" in values;
const json = "json" in values;

if (
  "help" in values ||
  (!("version" in values) &&
    !("function" in values) &&
    positionals.length === 0)
) {
  console.log(
    `${bold(
      "elm-bench"
    )} - a small CLI utility for easy benchmarking of Elm code.`
  );
  usage();
  process.exit(0);
}

if ("version" in values && "function" in values) {
  console.error(
    red(
      "Can't use --version and --function at the same time, please choose only one."
    )
  );
  usage();
  process.exit(1);
}

const mode = (() => {
  if ("version" in values) {
    return "version";
  } else if ("function" in values) {
    return "function";
  } else {
    console.error(red("No --version or --function, please choose one"));
    usage();
    process.exit(1);
  }
})();

switch (mode) {
  case "version":
    await runVersionMode();
    process.exit(0);
  case "function":
    await runFunctionMode();
    process.exit(0);
  default:
    console.error(
      red(
        "elm-bench bug: unknown mode. Please report this to martin@janiczek.cz. Thank you!"
      )
    );
    process.exit(1);
}

async function runVersionMode() {
  const versions = [...values.version];
  const tempDirs = {};

  if (positionals.length < 1) {
    console.error(
      red(
        "No function name in --version mode. Please provide a function that's exposed in the "
      ) +
        blue("Main.elm") +
        red(" of all the versions.")
    );
    usage();
    process.exit(1);
  }

  const functionName = positionals[0];

  if (positionals.length < 2) {
    warnAboutNoArgs({ functionName });
  }

  const args = positionals.slice(1);

  let stopSpinner;
  // Say we're starting
  if (!json) {
    const argsButLast = args.slice(0, -1);
    const [lastArg] = args.slice(-1);
    const argsString =
      args.length > 1
        ? "s " + (argsButLast.map(blue).join(", ") + " and " + blue(lastArg))
        : " " + blue(lastArg);
    console.log(
      `Benchmarking function ${blue(functionName)} with arg${argsString}.`
    );

    stopSpinner = startSpinner();
    process.on("exit", stopSpinner);
  }

  // Make and run a separate benchmark for each version
  let results = { results: [] };
  for (const version of versions) {
    const versionInvocations = [`( "${version}", Main.${functionName} )`];
    const imports = ["Main"];
    const templates = {
      "main.js": mainJsCode,
      "elm.json": runnerElmJsonCode,
      "src/Benchmarks.elm": runnerElmCode({
        imports,
        benchmarkName: functionName,
        args,
        versionInvocations,
      }),
    };

    // Make a temporary directory with our template files
    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), "elm-bench-"));
    tempDirs[version] = tempDir;

    await writeTemplatesIntoTempDir({ templates, tempDir });

    // Combine the existing elm.json dependencies with the runner ones
    const projectDirs = [tempDir, version];
    const combinedDependencies = await combineElmJsonDependencies({
      projectDirs,
    });

    // Copy this project to the tempDir
    await copyElmProject(version, tempDir);

    const tempElmJsonPath = path.join(tempDir, "elm.json");
    const tempElmJson = JSON.parse(await fs.readFile(tempElmJsonPath, "utf-8"));
    tempElmJson.dependencies = combinedDependencies;
    if (
      !(
        tempElmJson["source-directories"].includes("src") ||
        tempElmJson["source-directories"].includes("src/")
      )
    ) {
      tempElmJson["source-directories"].push("src");
    }

    await fs.writeFile(
      tempElmJsonPath,
      JSON.stringify(tempElmJson, null, 4),
      "utf-8"
    );

    // Compile and run everything!
    await runElmMake({
      cwd: tempDir,
      file: path.join("src", "Benchmarks.elm"),
    });
    const versionResults = await runGeneratedProgram({ tempDir });
    results.results = [...results.results, ...versionResults.results];

    if (!keep) {
      await removeTempFiles({ tempDir });
    }
  }

  if (stopSpinner) {
    stopSpinner();
  }
  if (json) {
    printJsonResults({ results, cases: versions, keep, tempDirs });
  } else {
    printResults({ results, cases: versions });
    if (keep) {
      console.log("\nBenchmark code is in the following directories:");
      for (const [version, tempDir] of Object.entries(tempDirs)) {
        console.log(`- ${version}: ${blue(tempDir)}`);
      }
    }
  }
}

async function runFunctionMode() {
  const functions = [...values.function];
  if (positionals.length < 1) {
    warnAboutNoArgs({ functionName: null });
  }
  const args = positionals;

  let stopSpinner;
  if (!json) {
    // Say we're starting
    const argsButLast = args.slice(0, -1);
    const [lastArg] = args.slice(-1);
    const functionsString =
      functions.length > 1
        ? "s " + functions.map(blue).join(", ")
        : blue(functions[0]);
    const argsString =
      args.length > 1
        ? "s " + (argsButLast.map(blue).join(", ") + " and " + blue(lastArg))
        : blue(lastArg);
    console.log(
      `Benchmarking function${functionsString} with arg${argsString}.`
    );

    stopSpinner = startSpinner();
    process.on("exit", stopSpinner);
  }

  const projectDir = process.cwd();

  // Prepare the JS+Elm program

  // From: ["Main.removeOld", "Other.Optimized.removeNew"]
  // To:   ["Main", "Other.Optimized"]
  const imports = functions.map((func) =>
    func.split(".").slice(0, -1).join(".")
  );

  // From: ["Main.removeOld", "Other.Optimized.removeNew"]
  // To:   [`( "Main.removeOld", Main.removeOld )`, `( "Other.Optimized.removeNew", Other.Optimized.removeNew )`]
  const versionInvocations = functions.map((func) => `( "${func}", ${func} )`);

  const templates = {
    "main.js": mainJsCode,
    "elm.json": runnerElmJsonCode,
    "src/Benchmarks.elm": runnerElmCode({
      imports,
      benchmarkName: "benchmark",
      args,
      versionInvocations,
    }),
  };

  // Make a temporary directory with our template files
  const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), "elm-bench-"));

  await writeTemplatesIntoTempDir({ templates, tempDir });

  // Copy the current project's code into the tempDir
  /*
  Before:

  - src/Foo.elm
  - other-src/Bar.elm
  - elm.json

  After:

  - ${tempDir}/src/Foo.elm
  - ${tempDir}/other-src/Bar.elm
  - ${tempDir}/elm.json (with combined dependencies of this project + the runner)
  */

  // Copy files
  const currentElmJson = JSON.parse(await fs.readFile("elm.json", "utf-8"));
  const srcDirs = currentElmJson["source-directories"] ?? ["src"];
  const elmFiles = await Promise.all(srcDirs.map(findElmFiles)).then((files) =>
    files.flat()
  );

  for (const file of elmFiles) {
    const relativePath = path.relative(projectDir, file);
    const destPath = path.join(tempDir, relativePath);
    const destDir = path.dirname(destPath);
    await fs.mkdir(destDir, { recursive: true });
    await fs.copyFile(file, destPath);
  }

  // Make the final elm.json
  const projectDirs = [tempDir, projectDir];
  const combinedDependencies = await combineElmJsonDependencies({
    projectDirs,
  });

  const tempElmJsonPath = path.join(tempDir, "elm.json");
  const tempElmJson = JSON.parse(await fs.readFile(tempElmJsonPath, "utf-8"));
  tempElmJson.dependencies = combinedDependencies;
  tempElmJson["source-directories"] = srcDirs;
  await fs.writeFile(
    tempElmJsonPath,
    JSON.stringify(tempElmJson, null, 4),
    "utf-8"
  );

  // Compile and run everything!
  await runElmMake({ cwd: tempDir, file: path.join("src", "Benchmarks.elm") });
  const results = await runGeneratedProgram({ tempDir });

  if (stopSpinner) {
    stopSpinner();
  }
  if (json) {
    printJsonResults({ results, cases: functions, keep, tempDirs: [tempDir] });
  } else {
    printResults({ results, cases: functions });
    if (keep) {
      console.log("\nBenchmark code is in the following directory:");
      console.log(blue(tempDir));
    }
  }

  if (!keep) {
    await removeTempFiles({ tempDir });
  }
}

function printResults({ results, cases }) {
  /* Example of `results`:

    {
      "results": [
        { "name": [ "remove", "listRemoveOld" ], "nsPerRun": 316.43958596194926 },
        { "name": [ "remove", "listRemoveNew" ], "nsPerRun": 254.48914830045732 }
      ],
      "warning": null
    }

  Output:

    old   ████████████████████   316 ns/run   baseline
    new   ████████████████       254 ns/run   20% faster

  */

  const baseline = results.results[0].nsPerRun;
  const maxNameLength = Math.max(...cases.map((v) => v.length));
  const maxBarLength = 20;

  const fastestIndex = results.results.reduce(
    (minIndex, result, currentIndex, array) => {
      return result.nsPerRun < array[minIndex].nsPerRun
        ? currentIndex
        : minIndex;
    },
    0
  );

  process.stdout.write("\r \r\n");

  results.results.forEach((result, index) => {
    const { nsPerRun } = result;
    const case_ = cases[index];
    const barLength = Math.round((nsPerRun / baseline) * maxBarLength);
    const bar = "█".repeat(barLength);
    const nsRounded = Math.round(nsPerRun);
    const padding = " ".repeat(maxNameLength - case_.length);
    const isFastest = index === fastestIndex;

    let comparison = "";
    if (index === 0) {
      comparison = "baseline";
    } else {
      const percentDiff = Math.round((nsPerRun / baseline - 1) * 100);
      if (percentDiff > 0) {
        comparison = `${percentDiff}% slower`;
      } else if (percentDiff < 0) {
        comparison = `${Math.abs(percentDiff)}% faster`;
      } else {
        comparison = "same speed";
      }
    }

    const caseC = isFastest ? green(case_) : case_;
    const comparisonC = isFastest ? green(comparison) : comparison;

    console.log(
      `  ${caseC}${padding}   ${bar.padEnd(
        maxBarLength
      )}   ${nsRounded} ns/run   ${comparisonC}`
    );
  });

  if (results.warning) {
    console.warn("\nWarning:", results.warning);
  }
}

async function removeTempFiles({ tempDir }) {
  await fs.rm(tempDir, { recursive: true });
}

function warnAboutNoArgs({ functionName }) {
  console.error(
    red(
      "No arguments. This will make the benchmark meaningless (the benchmarked function is precomputed and benchmarks will take no time). Please make the function"
    ) +
      (functionName == null ? "s" : " " + blue(functionName)) +
      red(" take an ") +
      blue("()") +
      red(" argument and pass it here.")
  );
  usage();
  process.exit(1);
}

async function combineElmJsonDependencies({ projectDirs }) {
  const acc = { direct: {}, indirect: {} };

  for (const project of projectDirs) {
    const elmJsonPath = path.join(project, "elm.json");
    const elmJson = JSON.parse(await fs.readFile(elmJsonPath, "utf-8"));

    for (const depType of ["direct", "indirect"]) {
      for (const [pkg, ver] of Object.entries(elmJson.dependencies[depType])) {
        if (
          // not in the acc yet
          !acc[depType][pkg] ||
          // higher version than the one in acc
          semverGt(ver, acc[depType][pkg])
        ) {
          // put it into acc
          acc[depType][pkg] = ver;
        }
      }
    }
  }

  // Cleanup acc: if in both direct and indirect, merge into direct and remove from indirect
  for (const [pkg, ver] of Object.entries(acc.indirect)) {
    if (pkg in acc.direct) {
      if (semverGt(ver, acc.direct[pkg])) {
        acc.direct[pkg] = ver;
      }
      delete acc.indirect[pkg];
    }
  }

  return acc;
}

async function runElmMake({ file, cwd }) {
  const elmMakeCommand = `elm make ${file} --optimize --output elm.js`;
  try {
    const { stderr } = await exec(elmMakeCommand, { cwd, encoding: "utf-8" });
    if (stderr && stderr.length > 0) {
      if (stderr) {
        console.error("Elm make errors:");
        console.error(stderr);
      }
    }
  } catch (error) {
    console.error("Error running elm make:", error);
    throw error;
  }
}

async function findElmFiles(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = await Promise.all(
    entries.map((entry) => {
      const res = path.resolve(dir, entry.name);
      return entry.isDirectory() ? findElmFiles(res) : res;
    })
  );
  return files.flat().filter((file) => file.endsWith(".elm"));
}

async function runGeneratedProgram({ tempDir }) {
  const nodeCommand = "node main.js";
  try {
    const { stdout, stderr } = await exec(nodeCommand, {
      cwd: tempDir,
      encoding: "utf-8",
    });
    if (stderr && stderr.length > 0) {
      console.error("Node execution errors:");
      console.error(stderr);
    }

    const results = JSON.parse(stdout);
    return results;
  } catch (error) {
    console.error("Error running the generated program:", error);
    throw error;
  }
}

function runnerElmCode({ imports, benchmarkName, args, versionInvocations }) {
  const importsCode = imports.map((imp) => `import ${imp}`).join("\n");
  const argsCode = args.map((_, i) => `arg${i}`).join(" ");
  const argDefsCode = args
    .map((arg, i) => `arg${i} =\n    ${arg}`)
    .join("\n\n\n");
  const versionsCode = `[ ${versionInvocations.join("\n        , ")}
        ]`;

  return `port module Benchmarks exposing (main)

import Benchmark exposing (Benchmark)
import Benchmark.Alternative
import Benchmark.Runner.Cli
${importsCode}


port sendOutput : Benchmark.Runner.Cli.Output -> Cmd msg


main =
    Benchmark.Runner.Cli.program
        { suite = suite
        , sendOutput = sendOutput
        }


suite : Benchmark
suite =
    Benchmark.Alternative.rank
        "${benchmarkName}"
        (\\f -> f ${argsCode})
        ${versionsCode}


${argDefsCode}`;
}

async function writeTemplatesIntoTempDir({ templates, tempDir }) {
  // Write out the templates to the temporary directory
  for (const [fileName, content] of Object.entries(templates)) {
    const filePath = path.join(tempDir, fileName);
    const dirPath = path.dirname(filePath);

    // Ensure the directory exists
    await fs.mkdir(dirPath, { recursive: true });

    // Write the file
    await fs.writeFile(filePath, content, "utf-8");
  }
}

async function copyElmProject(src, dest) {
  // Read the "source-directories" from the elm.json file
  const elmJsonPath = path.join(src, "elm.json");
  const elmJson = JSON.parse(await fs.readFile(elmJsonPath, "utf-8"));
  const sourceDirs = elmJson["source-directories"] ?? ["src"];

  // Copy each source directory
  for (const sourceDir of sourceDirs) {
    const sourcePath = path.join(src, sourceDir);
    const destPath = path.join(dest, sourceDir);
    await copyRecursiveElm(sourcePath, destPath);
  }
}

async function copyRecursiveElm(src, dest) {
  const stats = await fs.stat(src);
  if (stats.isDirectory()) {
    // If it's a directory, create it in the destination and copy its contents
    await fs.mkdir(dest, { recursive: true });
    const entries = await fs.readdir(src);
    for (const entry of entries) {
      await copyRecursiveElm(path.join(src, entry), path.join(dest, entry));
    }
  } else {
    // If it's a file, copy it directly
    if (src.endsWith(".elm")) {
      await fs.copyFile(src, dest);
    }
  }
}

function printJsonResults({ results, cases, keep, tempDirs }) {
  /* Example of `results`:

    {
      "results": [
        { "name": [ "remove", "listRemoveOld" ], "nsPerRun": 316.43958596194926 },
        { "name": [ "remove", "listRemoveNew" ], "nsPerRun": 254.48914830045732 }
      ],
      "warning": null
    }

  Output:

    [ 
      { "name": "old", "nsPerRun": 316.43958596194926, "benchmarkDir": "/tmp/elm-bench-old", "warning": null },
      { "name": "new", "nsPerRun": 254.48914830045732, "benchmarkDir": "/tmp/elm-bench-new", "warning": null }
    ]

  */
  const json = results.results.map((result, i) => ({
    name: cases[i],
    nsPerRun: result.nsPerRun,
    benchmarkDir: keep ? tempDirs[cases[i]] : null,
    warning: results.warning ?? null,
  }));
  process.stdout.write(JSON.stringify(json, null, 2) + "\n");
}
