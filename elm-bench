#!/bin/sh
':' // ; cat "$0" | node --input-type=module - "$@" ; exit $?

// Copyright (c) 2024 The Lispark s.r.o. - All Rights Reserved
// Written by Martin Janiczek <martin@janiczek.cz>
// You're authorized to use this code on an unlimited number of machines.
// You're not authorized to distribute or sell this code to other people.

/*
elm-bench
---------
A small CLI utility for easy benchmarking of Elm code.

Dependencies: elm, node

Example usage:
  elm-bench -v ./old -v ./new remove 42 "List.range 0 1000"

Expects old and new to be directories containing Elm applications whose
`src/Main.elm` exposes the `remove` function. Each `remove` function should
accept an Int and a List Int. elm-bench will plug each `remove` function into
an elm-benchmark program and give you the results on the CLI:

$ elm-bench -v ./old -v ./new remove 42 "List.range 0 1000"
Benchmarking function remove with args 42 and List.range 0 1000.
  old   ████████████████████   316 ns/run   baseline
  new   ████████████████       254 ns/run   20% faster

TODO: Alternative way to run these: elm-bench --path src/Main.elm -f removeOld -f removeNew 42 "List.range 0 1000"
TODO: eject into elm-benchmark code (receive an arg saying where to put it, and use that instead of the temp dir, and don't delete that afterwards)
TODO: check the Debug.toString representation of the versions is the same, and show a warning if it's not
TODO: JSON report mode
TODO: use us, ms, s when it gets too big
TODO: allow specifying the path to the Elm compiler
TODO: usage screen in -h, --help or on arg parse error
TODO: be robust against arbitrary paths
TODO: test against benchmarked code that has a lot of tricky imports / package deps
*/

import { parseArgs, promisify } from "node:util";
import fs from "node:fs/promises";
import path from "node:path";
import os from "node:os";
import * as childProcess from "node:child_process";

const semverGt = (v1, v2) => {
  const parse = v => v.split('.').map(Number);
  const [major1, minor1, patch1] = parse(v1);
  const [major2, minor2, patch2] = parse(v2);

  if (major1 !== major2) return major1 > major2;
  if (minor1 !== minor2) return minor1 > minor2;
  return patch1 > patch2;
};

const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);
const capitalizePath = (str) => str.split(path.sep).map(capitalize).join(path.sep);
const pathToElm = (str) => str.split(path.sep).map(capitalize).join(".");
const elmToPath = (str) => str.split(".").join(path.sep);

const green = (str) => `\x1b[32m${str}\x1b[0m`;
const blue = (str) => `\x1b[34m${str}\x1b[0m`;
const red = (str) => `\x1b[31m${str}\x1b[0m`;
const dim = (str) => `\x1b[2m${str}\x1b[0m`;
const bold = (str) => `\x1b[1m${str}\x1b[0m`;

function startSpinner() {
  const characters = [
    "⠀","⠁","⠂","⠃","⠄","⠅","⠆","⠇","⠈","⠉","⠊","⠋","⠌","⠍","⠎","⠏",
    "⠐","⠑","⠒","⠓","⠔","⠕","⠖","⠗","⠘","⠙","⠚","⠛","⠜","⠝","⠞","⠟",
    "⠠","⠡","⠢","⠣","⠤","⠥","⠦","⠧","⠨","⠩","⠪","⠫","⠬","⠭","⠮","⠯",
    "⠰","⠱","⠲","⠳","⠴","⠵","⠶","⠷","⠸","⠹","⠺","⠻","⠼","⠽","⠾","⠿",
    "⡀","⡁","⡂","⡃","⡄","⡅","⡆","⡇","⡈","⡉","⡊","⡋","⡌","⡍","⡎","⡏",
    "⡐","⡑","⡒","⡓","⡔","⡕","⡖","⡗","⡘","⡙","⡚","⡛","⡜","⡝","⡞","⡟",
    "⡠","⡡","⡢","⡣","⡤","⡥","⡦","⡧","⡨","⡩","⡪","⡫","⡬","⡭","⡮","⡯",
    "⡰","⡱","⡲","⡳","⡴","⡵","⡶","⡷","⡸","⡹","⡺","⡻","⡼","⡽","⡾","⡿",
    "⢀","⢁","⢂","⢃","⢄","⢅","⢆","⢇","⢈","⢉","⢊","⢋","⢌","⢍","⢎","⢏",
    "⢐","⢑","⢒","⢓","⢔","⢕","⢖","⢗","⢘","⢙","⢚","⢛","⢜","⢝","⢞","⢟",
    "⢠","⢡","⢢","⢣","⢤","⢥","⢦","⢧","⢨","⢩","⢪","⢫","⢬","⢭","⢮","⢯",
    "⢰","⢱","⢲","⢳","⢴","⢵","⢶","⢷","⢸","⢹","⢺","⢻","⢼","⢽","⢾","⢿",
    "⣀","⣁","⣂","⣃","⣄","⣅","⣆","⣇","⣈","⣉","⣊","⣋","⣌","⣍","⣎","⣏",
    "⣐","⣑","⣒","⣓","⣔","⣕","⣖","⣗","⣘","⣙","⣚","⣛","⣜","⣝","⣞","⣟",
    "⣠","⣡","⣢","⣣","⣤","⣥","⣦","⣧","⣨","⣩","⣪","⣫","⣬","⣭","⣮","⣯",
    "⣰","⣱","⣲","⣳","⣴","⣵","⣶","⣷","⣸","⣹","⣺","⣻","⣼","⣽","⣾","⣿",
  ];
  const cursorEsc = {
    hide: '\u001B[?25l',
    show: '\u001B[?25h',
  };
  process.stdout.write(cursorEsc.hide);

  let i = 0;
  const timer = setInterval(function () {
    process.stdout.write("\r" + blue(characters[i++]));
    i = i >= characters.length ? 0 : i;
  }, 100);

  return () => {
    clearInterval(timer);
    process.stdout.write("\r");
    process.stdout.write(cursorEsc.show);
  };
}

function usage() {
  console.error(`
${dim("Usage:")}
  ${bold("elm-bench")} [options] <function-name> <arg> [<arg>...]

${dim("Options:")}
  -v, --version <version-dir>  Specify a version directory (can be used multiple times)

${dim("Arguments:")}
  <function-name>              Name of the function to benchmark
  <arg>                        Arguments to pass to the function (1+)

${dim("Example:")}
  elm-bench ${dim("-v")} ./old ${dim("-v")} ./new remove 42 "List.range 0 1000"
  elm-bench ${dim("-v")} ./old ${dim("-v")} ./new scenario "()"
`);

}

// Parse arguments

const { values, positionals } = parseArgs({
  options: {
    version: {
      type: "string",
      short: "v",
      multiple: true,
    },
  },
  allowPositionals: true,
});

if (!("version" in values) && positionals.length === 0) {

  console.log(`${bold("elm-bench")} - a small CLI utility for easy benchmarking of Elm code.`);
  usage();
  process.exit(0);
}


if (!("version" in values)) {
  console.error(red("No versions, please specify at least one version directory"));
  usage();
  process.exit(1);
}

const versions = [...values.version];

if (positionals.length < 1) {
  console.error(red("No function name. Please provide a function that's exposed in the ")
  + blue("Main.elm")
  + red(" of all the versions."));
  usage();
  process.exit(1);
}

const functionName = positionals[0];

if (positionals.length < 2) {
  console.error(red("No arguments. This will make the benchmark meaningless (the benchmarked function is precomputed and benchmarks will take no time). Please make the function ")
  + blue(functionName)
  + red(" take an ")
  + blue("()")
  + red(" argument and pass it here."));
  usage();
  process.exit(1);
}

const args = positionals.slice(1);

const argsButLast = args.slice(0, -1);
const [lastArg] = args.slice(-1);

const argsString = args.length > 0 ?
  (" with args " + (args.length > 1
    ? (argsButLast.map(blue).join(", ") + " and " + blue(lastArg))
    : blue(lastArg)))
  : "";

console.log(`Benchmarking function ${blue(functionName)}${argsString}.`);
const stopSpinner = startSpinner();

process.on('exit', stopSpinner);

const versionDirs = versions.map((version) => path.relative(".", version));

// Prepare the JS+Elm program

const versionsCode = `[ ${versionDirs
  .map(
    (version) =>
      `( "${version}", Version.${pathToElm(version)}.${functionName} )`
  )
  .join("\n        , ")}
        ]`;

const argsCode = args.map((_, i) => `arg${i}`).join(" ");

const importsCode = versionDirs
  .map((version) => `import Version.${pathToElm(version)}`)
  .join("\n");

const argDefsCode = args.map((arg, i) => `arg${i} =\n    ${arg}`).join("\n\n\n");

const templates = {
  "main.js": `
const {Elm} = require('./elm.js');

const app = Elm.Benchmarks.init();

app.ports.sendOutput.subscribe((output) => {
    console.log(JSON.stringify(output, null, 2));
});
`,
  "elm.json": `
{
    "type": "application",
    "source-directories": [
        "src"
    ],
    "elm-version": "0.19.1",
    "dependencies": {
        "direct": {
            "Janiczek/elm-benchmark-cli-runner": "1.0.0",
            "elm/core": "1.0.5",
            "elm-explorations/benchmark": "1.0.2",
            "lue-bird/elm-alternative-benchmark-runner": "1.0.0"
        },
        "indirect": {
            "BrianHicks/elm-trend": "2.1.3",
            "avh4/elm-color": "1.0.0",
            "elm/browser": "1.0.2",
            "elm/html": "1.0.0",
            "elm/json": "1.1.3",
            "elm/regex": "1.0.0",
            "elm/time": "1.0.0",
            "elm/url": "1.0.0",
            "elm/virtual-dom": "1.0.3",
            "mdgriffith/elm-ui": "1.1.8",
            "mdgriffith/style-elements": "5.0.2",
            "miniBill/elm-ui-with-context": "1.1.0",
            "robinheghan/murmur3": "1.0.0"
        }
    },
    "test-dependencies": {
        "direct": {},
        "indirect": {}
    }
}
`,
  "src/Benchmarks.elm": `
port module Benchmarks exposing (main)

import Benchmark exposing (Benchmark)
import Benchmark.Alternative
import Benchmark.Runner.Cli
{{IMPORTS}}


port sendOutput : Benchmark.Runner.Cli.Output -> Cmd msg


main =
    Benchmark.Runner.Cli.program
        { suite = suite
        , sendOutput = sendOutput
        }


suite : Benchmark
suite =
    Benchmark.Alternative.rank
        "{{FUNCTION_NAME}}"
        (\\f -> f {{ARGS}})
        {{VERSIONS}}


{{ARG_DEFS}}
`
    .replace("{{FUNCTION_NAME}}", functionName)
    .replace("{{VERSIONS}}", versionsCode)
    .replace("{{ARGS}}", argsCode)
    .replace("{{IMPORTS}}", importsCode)
    .replace("{{ARG_DEFS}}", argDefsCode)

}

// Make a temporary directory with our template files
const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), "elm-bench-"));

// Write out the templates to the temporary directory
for (const [fileName, content] of Object.entries(templates)) {
  const filePath = path.join(tempDir, fileName);
  const dirPath = path.dirname(filePath);

  // Ensure the directory exists
  await fs.mkdir(dirPath, { recursive: true });

  // Write the file
  await fs.writeFile(filePath, content, "utf-8");
}

// Copy the versions' code into src/Versions, change the module declaration and rename the Main module
/*
Before:

- listRemoveOld/src/WhateverElse.elm
- listRemoveOld/src/Main.elm
- listRemoveOld/elm.json

- listRemoveNew/src/WhateverElse.elm
- listRemoveNew/src/Main.elm
- listRemoveNew/elm.json

After:

- ${tempDir}/src/Version/ListRemoveOld/WhateverElse.elm (with changed module name and imports)
- ${tempDir}/src/Version/ListRemoveOld.elm              (with changed module name and imports)
- ${tempDir}/src/Version/ListRemoveNew/WhateverElse.elm (with changed module name and imports)
- ${tempDir}/src/Version/ListRemoveNew.elm              (with changed module name and imports)
- ${tempDir}/elm.json (with combined dependencies of all versions)
*/

async function findElmFiles(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = await Promise.all(
    entries.map((entry) => {
      const res = path.resolve(dir, entry.name);
      return entry.isDirectory() ? findElmFiles(res) : res;
    })
  );
  return files.flat().filter((file) => file.endsWith(".elm"));
}

for (const version of versionDirs) {
  // version == example/old
  const versionCapitalized = capitalizePath(version); // Example/Old
  const versionModule = pathToElm(version); // Example.Old
  const srcDir = path.join(version, "src");

  const outSrcDir = path.join(tempDir, "src");
  const outVersionDir = path.join(tempDir, "src", "Version");
  const outDestDir = path.join(tempDir, "src", "Version", versionCapitalized);

  await fs.mkdir(outDestDir, { recursive: true });

  const elmFiles = await findElmFiles(srcDir);

  for (const file of elmFiles) {
    const destPath = file.endsWith("Main.elm")
      ? path.join(outVersionDir, `${versionCapitalized}.elm`)
      : path.join(outDestDir, path.relative(srcDir, file));

    let content = await fs.readFile(file, "utf-8");

    // Modify module declaration
    content = content.replace(
      /^module\s+(\w+)(?:\s+exposing\s*\(([\s\S]*?)\))?/m,
      `module Version.${versionModule}${file.endsWith("Main.elm") ? "" : `.${path.basename(file, ".elm")}`
      } exposing ($2)`
    );

    // Modify imports
    content = content.replace(
      /^import\s+(\w+(?:\.\w+)*)/gm,
      (match, module) => {
        if (elmFiles.some((file) => file.includes(`${elmToPath(module)}.elm`))) {
          return `import Version.${versionModule}.${module} as ${module}`;
        }
        return match;
      }
    );

    await fs.mkdir(path.dirname(destPath), { recursive: true });
    await fs.writeFile(destPath, content, "utf-8");
  }
}

// Combine elm.json dependencies
const combinedDependencies = { direct: {}, indirect: {} };
for (const version of versionDirs) {
  const elmJsonPath = path.join(version, "elm.json");
  const elmJson = JSON.parse(await fs.readFile(elmJsonPath, "utf-8"));

  for (const depType of ["direct", "indirect"]) {
    for (const [pkg, ver] of Object.entries(elmJson.dependencies[depType])) {
      if (
        !combinedDependencies[depType][pkg] ||
        semverGt(ver, combinedDependencies[depType][pkg])
      ) {
        combinedDependencies[depType][pkg] = ver;
      }
    }
  }
}

// Update the temporary project's elm.json
const tempElmJsonPath = path.join(tempDir, "elm.json");
const tempElmJson = JSON.parse(await fs.readFile(tempElmJsonPath, "utf-8"));

// Merge dependencies, preferring direct over indirect and higher semver
for (const depType of ["direct", "indirect"]) {
  tempElmJson.dependencies[depType] = {
    ...tempElmJson.dependencies[depType],
    ...Object.fromEntries(
      Object.entries(combinedDependencies[depType]).map(([pkg, ver]) => {
        const existingVer = tempElmJson.dependencies[depType][pkg];
        const directVer = tempElmJson.dependencies.direct[pkg];

        if (directVer) {
          // If it exists in direct dependencies, use that version
          return [pkg, directVer];
        } else if (existingVer) {
          // If it exists in the same dependency type, use the higher semver
          return [pkg, semverGt(ver, existingVer) ? ver : existingVer];
        } else {
          // If it doesn't exist in tempElmJson, add it
          return [pkg, ver];
        }
      })
    ),
  };
}

// Move any remaining indirect dependencies to direct if they exist in both
for (const [pkg, _] of Object.entries(tempElmJson.dependencies.indirect)) {
  if (pkg in tempElmJson.dependencies.direct) {
    delete tempElmJson.dependencies.indirect[pkg];
  }
}
await fs.writeFile(
  tempElmJsonPath,
  JSON.stringify(tempElmJson, null, 4),
  "utf-8"
);

// Run elm make on the generated Elm code
const exec = promisify(childProcess.exec);

const elmMakeCommand = `elm make src/Benchmarks.elm --optimize --output elm.js`;
try {
  const { stderr } = await exec(elmMakeCommand, { cwd: tempDir, encoding: "utf-8" });
  if (stderr && stderr.length > 0) {
    if (stderr) {
      console.error("Elm make errors:");
      console.error(stderr);
    }
  }
} catch (error) {
  console.error("Error running elm make:", error);
  throw error;
}

// Run the generated program and get the results
async function runGeneratedProgram() {
  const nodeCommand = 'node main.js';
  try {
    const { stdout, stderr } = await exec(nodeCommand, { cwd: tempDir, encoding: "utf-8" });
    if (stderr && stderr.length > 0) {
      console.error("Node execution errors:");
      console.error(stderr);
    }

    const results = JSON.parse(stdout);
    return results;
  } catch (error) {
    console.error("Error running the generated program:", error);
    throw error;
  }
}

const results = await runGeneratedProgram();
stopSpinner();

// Print the results

/* Example of `results`:

  {
    "results": [
      { "name": [ "remove", "listRemoveOld" ], "nsPerRun": 316.43958596194926 },
      { "name": [ "remove", "listRemoveNew" ], "nsPerRun": 254.48914830045732 }
    ],
    "warning": null
  }

Output:

  old   ████████████████████   316 ns/run   baseline
  new   ████████████████       254 ns/run   20% faster

*/

const baseline = results.results[0].nsPerRun;
const maxNameLength = Math.max(...versions.map((v) => v.length));
const maxBarLength = 20;

const fastestIndex = results.results.reduce((minIndex, result, currentIndex, array) => {
  return result.nsPerRun < array[minIndex].nsPerRun ? currentIndex : minIndex;
}, 0);

results.results.forEach((result, index) => {
  const { nsPerRun } = result;
  const version = versions[index];
  const barLength = Math.round((nsPerRun / baseline) * maxBarLength);
  const bar = '█'.repeat(barLength);
  const nsRounded = Math.round(nsPerRun);
  const padding = ' '.repeat(maxNameLength - version.length);
  const isFastest = index === fastestIndex;

  let comparison = '';
  if (index === 0) {
    comparison = 'baseline';
  } else {
    const percentDiff = Math.round((nsPerRun / baseline - 1) * 100);
    if (percentDiff > 0) {
      comparison = `${percentDiff}% slower`;
    } else if (percentDiff < 0) {
      comparison = `${Math.abs(percentDiff)}% faster`;
    } else {
      comparison = 'same speed';
    }
  }

  const versionC = isFastest ? green(version) : version;
  const comparisonC = isFastest ? green(comparison) : comparison;

  console.log(`  ${versionC}${padding}   ${bar.padEnd(maxBarLength)}   ${nsRounded} ns/run   ${comparisonC}`);
});

if (results.warning) {
  console.warn("Warning:", results.warning);
}

// Remove the temporary files

await fs.rm(tempDir, { recursive: true });
