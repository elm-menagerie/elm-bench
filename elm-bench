#!/bin/sh
':' // ; cat "$0" | node --input-type=module - "$@" ; exit $?

// Copyright (c) 2024 The Lispark s.r.o. - All Rights Reserved
// Written by Martin Janiczek <martin@janiczek.cz>
// You're authorized to use this code on an unlimited number of machines.
// You're not authorized to distribute or sell this code to other people.

/*
elm-bench
---------
A small CLI utility for easy benchmarking of Elm code.

Dependencies: elm, node, git

TODO: specify extra imports for the -f mode?
TODO: check the Debug.toString representation of the versions is the same, and show a warning if it's not
TODO: use us, ms, s when it gets too big
TODO: be robust against arbitrary paths
TODO: stop spinner before each error message
*/

import { parseArgs, promisify } from "node:util";
import fs from "node:fs/promises";
import path from "node:path";
import crypto from "node:crypto";
import os from "node:os";
import * as childProcess from "node:child_process";

const exec = promisify(childProcess.exec);

const semverGt = (v1, v2) => {
  const parse = (v) => v.split(".").map(Number);
  const [major1, minor1, patch1] = parse(v1);
  const [major2, minor2, patch2] = parse(v2);

  if (major1 !== major2) return major1 > major2;
  if (minor1 !== minor2) return minor1 > minor2;
  return patch1 > patch2;
};

const green = (str) => `\x1b[32m${str}\x1b[0m`;
const blue = (str) => `\x1b[34m${str}\x1b[0m`;
const red = (str) => `\x1b[31m${str}\x1b[0m`;
const dim = (str) => `\x1b[2m${str}\x1b[0m`;
const bold = (str) => `\x1b[1m${str}\x1b[0m`;

function startSpinner() {
  const characters = [ "⠀", "⠁", "⠂", "⠃", "⠄", "⠅", "⠆", "⠇", "⠈", "⠉", "⠊", "⠋", "⠌", "⠍", "⠎", "⠏", "⠐", "⠑", "⠒", "⠓", "⠔", "⠕", "⠖", "⠗", "⠘", "⠙", "⠚", "⠛", "⠜", "⠝", "⠞", "⠟", "⠠", "⠡", "⠢", "⠣", "⠤", "⠥", "⠦", "⠧", "⠨", "⠩", "⠪", "⠫", "⠬", "⠭", "⠮", "⠯", "⠰", "⠱", "⠲", "⠳", "⠴", "⠵", "⠶", "⠷", "⠸", "⠹", "⠺", "⠻", "⠼", "⠽", "⠾", "⠿", "⡀", "⡁", "⡂", "⡃", "⡄", "⡅", "⡆", "⡇", "⡈", "⡉", "⡊", "⡋", "⡌", "⡍", "⡎", "⡏", "⡐", "⡑", "⡒", "⡓", "⡔", "⡕", "⡖", "⡗", "⡘", "⡙", "⡚", "⡛", "⡜", "⡝", "⡞", "⡟", "⡠", "⡡", "⡢", "⡣", "⡤", "⡥", "⡦", "⡧", "⡨", "⡩", "⡪", "⡫", "⡬", "⡭", "⡮", "⡯", "⡰", "⡱", "⡲", "⡳", "⡴", "⡵", "⡶", "⡷", "⡸", "⡹", "⡺", "⡻", "⡼", "⡽", "⡾", "⡿", "⢀", "⢁", "⢂", "⢃", "⢄", "⢅", "⢆", "⢇", "⢈", "⢉", "⢊", "⢋", "⢌", "⢍", "⢎", "⢏", "⢐", "⢑", "⢒", "⢓", "⢔", "⢕", "⢖", "⢗", "⢘", "⢙", "⢚", "⢛", "⢜", "⢝", "⢞", "⢟", "⢠", "⢡", "⢢", "⢣", "⢤", "⢥", "⢦", "⢧", "⢨", "⢩", "⢪", "⢫", "⢬", "⢭", "⢮", "⢯", "⢰", "⢱", "⢲", "⢳", "⢴", "⢵", "⢶", "⢷", "⢸", "⢹", "⢺", "⢻", "⢼", "⢽", "⢾", "⢿", "⣀", "⣁", "⣂", "⣃", "⣄", "⣅", "⣆", "⣇", "⣈", "⣉", "⣊", "⣋", "⣌", "⣍", "⣎", "⣏", "⣐", "⣑", "⣒", "⣓", "⣔", "⣕", "⣖", "⣗", "⣘", "⣙", "⣚", "⣛", "⣜", "⣝", "⣞", "⣟", "⣠", "⣡", "⣢", "⣣", "⣤", "⣥", "⣦", "⣧", "⣨", "⣩", "⣪", "⣫", "⣬", "⣭", "⣮", "⣯", "⣰", "⣱", "⣲", "⣳", "⣴", "⣵", "⣶", "⣷", "⣸", "⣹", "⣺", "⣻", "⣼", "⣽", "⣾", "⣿" ];
  const cursorEsc = {
    hide: "\u001B[?25l",
    show: "\u001B[?25h",
  };
  process.stdout.write(cursorEsc.hide);

  let i = 0;
  const timer = setInterval(function () {
    process.stdout.write("\r" + blue(characters[i++]));
    i = i >= characters.length ? 0 : i;
  }, 100);

  return () => {
    clearInterval(timer);
    process.stdout.write("\r");
    process.stdout.write(cursorEsc.show);
  };
}

function usage() {
  console.error(`
${dim("Usage:")}

${dim("-f/--function mode:")}
  This mode benchmarks and compares multiple functions in the same Elm project.
  The project root is taken to be the current working directory.
  All functions will take the same set of arguments.
  Provide one or more -f flags with qualified function names:

    ${bold("elm-bench")} ${dim("[")}-f ${blue("QUALIFIED_FUNCTION")}${dim("]+")} ${dim("[")}${blue("ARG")}${dim("]+")}

    elm-bench ${dim("-f")} Foobar.run ${dim("-f")} Foobar.Optimized.run 1024
    elm-bench ${dim("-f")} Main.removeOld ${dim("-f")} Main.removeNew 42 "List.range 0 1000"

${dim("-g/--git mode:")}
  This mode benchmarks and compares the same function across multiple Git revisions.
  (This will be done via \`git worktree\` calls.)
  All functions will take the same set of arguments.

    ${bold("elm-bench")} ${dim("[")}-g ${blue("GIT_REVISION")}${dim("]+")} ${blue("QUALIFIED_FUNCTION")} ${dim("[")}${blue("ARG")}${dim("]+")}

    elm-bench ${dim("-g")} main ${dim("-g")} HEAD ${dim("-g")} 3de0823 Foobar.remove 42 "List.range 0 1000"

${dim("-v/--version mode:")}
  This mode benchmarks and compares the same function across multiple Elm projects.
  All functions will take the same set of arguments.

    ${bold("elm-bench")} ${dim("[")}-v ${blue("VERSION_DIR")}${dim("]+")} ${blue("QUALIFIED_FUNCTION")} ${dim("[")}${blue("ARG")}${dim("]+")}

    elm-bench ${dim("-v")} ./old ${dim("-v")} ./new Foobar.remove 42 "List.range 0 1000"
    elm-bench ${dim("-v")} ./old ${dim("-v")} ./new Main.scenario "()"

${dim("Flags:")}
  -h, --help            Show this help message
  -k, --keep            Keep benchmark code in a temporary directory and print its path
  -j, --json            Print results in JSON format, minimize verbosity
  --compiler ELM_PATH   Path to the Elm compiler
`);
}

const mainJsCode = `const {Elm} = require('./elm.js');

const app = Elm.Benchmarks.init();

app.ports.sendOutput.subscribe((output) => {
    console.log(JSON.stringify(output, null, 2));
});`;

const runnerElmJsonCode = `{
    "type": "application",
    "source-directories": [
        "src"
    ],
    "elm-version": "0.19.1",
    "dependencies": {
        "direct": {
            "Janiczek/elm-benchmark-cli-runner": "1.0.0",
            "elm/core": "1.0.5",
            "elm-explorations/benchmark": "1.0.2",
            "lue-bird/elm-alternative-benchmark-runner": "1.0.0"
        },
        "indirect": {
            "BrianHicks/elm-trend": "2.1.3",
            "avh4/elm-color": "1.0.0",
            "elm/browser": "1.0.2",
            "elm/html": "1.0.0",
            "elm/json": "1.1.3",
            "elm/regex": "1.0.0",
            "elm/time": "1.0.0",
            "elm/url": "1.0.0",
            "elm/virtual-dom": "1.0.3",
            "mdgriffith/elm-ui": "1.1.8",
            "mdgriffith/style-elements": "5.0.2",
            "miniBill/elm-ui-with-context": "1.1.0",
            "robinheghan/murmur3": "1.0.0"
        }
    },
    "test-dependencies": {
        "direct": {},
        "indirect": {}
    }
}`;

// Parse arguments

const { values, positionals } = parseArgs({
  options: {
    help: {
      type: "boolean",
      short: "h",
      multiple: false,
    },
    keep: {
      type: "boolean",
      short: "k",
      multiple: false,
    },
    json: {
      type: "boolean",
      short: "j",
      multiple: false,
    },
    version: {
      type: "string",
      short: "v",
      multiple: true,
    },
    git: {
      type: "string",
      short: "g",
      multiple: true,
    },
    function: {
      type: "string",
      short: "f",
      multiple: true,
    },
    compiler: {
      type: "string",
      multiple: false,
    },
  },
  allowPositionals: true,
});

const keep = "keep" in values;
const json = "json" in values;
const elmCompiler = "compiler" in values ? values.compiler : "elm";

const usesGit = "git" in values;
const usesVersion = "version" in values;
const usesFunction = "function" in values;

if (
  "help" in values ||
  (!usesVersion && !usesFunction && !usesGit && positionals.length === 0)
) {
  console.log(
    `${bold(
      "elm-bench"
    )} - a small CLI utility for easy benchmarking of Elm code.`
  );
  usage();
  process.exit(0);
}

if ([usesGit,usesVersion,usesFunction].filter(x=>x).length > 1) {
  console.error(red("Can only use one of --version, --function or --git at the same time."));
  usage();
  process.exit(1);
}

const mode = (() => {
  if (usesVersion) {
    return "version";
  } else if (usesFunction) {
    return "function";
  } else if (usesGit) {
    return "git";
  } else {
    console.error(red("No --version, --function or --git, please choose one"));
    usage();
    process.exit(1);
  }
})();

switch (mode) {
  case "version":
    await runVersionMode();
    process.exit(0);
  case "function":
    await runFunctionMode();
    process.exit(0);
  case "git":
    await runGitMode();
    process.exit(0);
  default:
    console.error(
      red(
        "elm-bench bug: unknown mode. Please report this to martin@janiczek.cz. Thank you!"
      )
    );
    process.exit(1);
}

async function runVersionMode() {
  const versions = [...values.version];
  const tempDirs = {};

  if (positionals.length < 1) {
    console.error(red("No function name in --version mode. Please provide a function that's exposed in all the versions."));
    usage();
    process.exit(1);
  }

  const functionName = positionals[0];

  if (positionals.length < 2) {
    warnAboutNoArgs({ functionName });
  }

  const args = positionals.slice(1);

  let stopSpinner;
  // Say we're starting
  if (!json) {
    const argsButLast = args.slice(0, -1);
    const [lastArg] = args.slice(-1);
    const argsString =
      args.length > 1
        ? "s " + (argsButLast.map(blue).join(", ") + " and " + blue(lastArg))
        : " " + blue(lastArg);
    console.log(
      `Benchmarking function ${blue(functionName)} with arg${argsString}.`
    );

    stopSpinner = startSpinner();
    process.on("exit", stopSpinner);
  }

  // Make and run a separate benchmark for each version
  let results = { results: [] };
  for (const version of versions) {
    const versionInvocations = [`( "${version}", ${functionName} )`]; // ( "v1.2.3", Foobar.Optimized.xyz )
    const imports = [functionName.split(".").slice(0, -1).join(".")]; // Foobar.Optimized.xyz -> Foobar.Optimized
    const templates = {
      "main.js": mainJsCode,
      "elm.json": runnerElmJsonCode,
      "src/Benchmarks.elm": runnerElmCode({
        imports,
        benchmarkName: functionName,
        args,
        versionInvocations,
      }),
    };

    // Make a temporary directory with our template files
    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), "elm-bench-"));
    tempDirs[version] = tempDir;

    await writeTemplatesIntoTempDir({ templates, tempDir });

    // Combine the existing elm.json dependencies with the runner ones
    const projectDirs = [tempDir, version];
    const combinedDependencies = await combineElmJsonDependencies({
      projectDirs,
    });

    // Copy this project to the tempDir
    await copyElmProject(version, tempDir);

    const tempElmJsonPath = path.join(tempDir, "elm.json");
    const tempElmJson = JSON.parse(await fs.readFile(tempElmJsonPath, "utf-8"));
    tempElmJson.dependencies = combinedDependencies;
    if (
      !(
        tempElmJson["source-directories"].includes("src") ||
        tempElmJson["source-directories"].includes("src/")
      )
    ) {
      tempElmJson["source-directories"].push("src");
    }

    await fs.writeFile(
      tempElmJsonPath,
      JSON.stringify(tempElmJson, null, 4),
      "utf-8"
    );

    // Compile and run everything!
    await runElmMake({
      cwd: tempDir,
      file: path.join("src", "Benchmarks.elm"),
    });
    const versionResults = await runGeneratedProgram({ tempDir });
    results.results = [...results.results, ...versionResults.results];

    if (!keep) {
      await removeTempFiles({ tempDir });
    }
  }

  if (stopSpinner) {
    stopSpinner();
  }
  if (json) {
    printJsonResults({ results, cases: versions, keep, tempDirs });
  } else {
    printResults({ results, cases: versions });
    if (keep) {
      console.log("\nBenchmark code is in the following directories:");
      for (const [version, tempDir] of Object.entries(tempDirs)) {
        console.log(`- ${version}: ${blue(tempDir)}`);
      }
    }
  }
}

async function runFunctionMode() {
  const functions = [...values.function];
  if (positionals.length < 1) {
    warnAboutNoArgs({ functionName: null });
  }
  const args = positionals;

  let stopSpinner;
  if (!json) {
    // Say we're starting
    const argsButLast = args.slice(0, -1);
    const [lastArg] = args.slice(-1);
    const functionsString =
      functions.length > 1
        ? "s " + functions.map(blue).join(", ")
        : blue(functions[0]);
    const argsString =
      args.length > 1
        ? "s " + (argsButLast.map(blue).join(", ") + " and " + blue(lastArg))
        : " " + blue(lastArg);
    console.log(
      `Benchmarking function${functionsString} with arg${argsString}.`
    );

    stopSpinner = startSpinner();
    process.on("exit", stopSpinner);
  }

  const projectDir = process.cwd();

  // Prepare the JS+Elm program

  // From: ["Main.removeOld", "Other.Optimized.removeNew"]
  // To:   ["Main", "Other.Optimized"]
  const imports = functions.map((func) =>
    func.split(".").slice(0, -1).join(".")
  );

  // From: ["Main.removeOld", "Other.Optimized.removeNew"]
  // To:   [`( "Main.removeOld", Main.removeOld )`, `( "Other.Optimized.removeNew", Other.Optimized.removeNew )`]
  const versionInvocations = functions.map((func) => `( "${func}", ${func} )`);

  const templates = {
    "main.js": mainJsCode,
    "elm.json": runnerElmJsonCode,
    "src/Benchmarks.elm": runnerElmCode({
      imports,
      benchmarkName: "benchmark",
      args,
      versionInvocations,
    }),
  };

  // Make a temporary directory with our template files
  const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), "elm-bench-"));

  await writeTemplatesIntoTempDir({ templates, tempDir });

  // Copy the current project's code into the tempDir
  /*
  Before:

  - src/Foo.elm
  - other-src/Bar.elm
  - elm.json

  After:

  - ${tempDir}/src/Foo.elm
  - ${tempDir}/other-src/Bar.elm
  - ${tempDir}/elm.json (with combined dependencies of this project + the runner)
  */

  // Copy files
  const currentElmJson = JSON.parse(await fs.readFile("elm.json", "utf-8"));
  const srcDirs = currentElmJson["source-directories"] ?? ["src"];
  const elmFiles = await Promise.all(srcDirs.map(findElmFiles)).then((files) =>
    files.flat()
  );

  for (const file of elmFiles) {
    const relativePath = path.relative(projectDir, file);
    const destPath = path.join(tempDir, relativePath);
    const destDir = path.dirname(destPath);
    await fs.mkdir(destDir, { recursive: true });
    await fs.copyFile(file, destPath);
  }

  // Make the final elm.json
  const projectDirs = [tempDir, projectDir];
  const combinedDependencies = await combineElmJsonDependencies({
    projectDirs,
  });

  const tempElmJsonPath = path.join(tempDir, "elm.json");
  const tempElmJson = JSON.parse(await fs.readFile(tempElmJsonPath, "utf-8"));
  tempElmJson.dependencies = combinedDependencies;
  tempElmJson["source-directories"] = srcDirs;
  await fs.writeFile(
    tempElmJsonPath,
    JSON.stringify(tempElmJson, null, 4),
    "utf-8"
  );

  // Compile and run everything!
  await runElmMake({ cwd: tempDir, file: path.join("src", "Benchmarks.elm") });
  const results = await runGeneratedProgram({ tempDir });

  if (stopSpinner) {
    stopSpinner();
  }
  if (json) {
    printJsonResults({ results, cases: functions, keep, tempDirs: [tempDir] });
  } else {
    printResults({ results, cases: functions });
    if (keep) {
      console.log("\nBenchmark code is in the following directory:");
      console.log(blue(tempDir));
    }
  }

  if (!keep) {
    await removeTempFiles({ tempDir });
  }
}

async function runGitMode() {
  const revisions = [...values.git];
  const tempDirs = {};

  if (positionals.length < 1) {
    console.error(red("No function name in --git mode. Please provide a function that's exposed in the "));
  }

  const functionName = positionals[0];

  if (positionals.length < 2) {
    warnAboutNoArgs({ functionName });
  }

  const args = positionals.slice(1);

  let stopSpinner;
  // Say we're starting
  if (!json) {
    const argsButLast = args.slice(0, -1);
    const [lastArg] = args.slice(-1);
    const argsString =
      args.length > 1
        ? "s " + (argsButLast.map(blue).join(", ") + " and " + blue(lastArg))
        : " " + blue(lastArg);
    console.log(
      `Benchmarking function ${blue(functionName)} with arg${argsString}.`
    );

    stopSpinner = startSpinner();
    process.on("exit", stopSpinner);
  }
  
  // Error if the cwd is not a git repository
  try {
    await exec("git rev-parse --is-inside-work-tree");
  } catch (e) {
    console.error(red("You must run elm-bench -g inside a git repository."));
    process.exit(1);
  }

  const originalBranch = (await exec("git rev-parse --abbrev-ref HEAD")).stdout.trim();

  // Make a temporary git branch and check it out. This is so that we can `git
  // worktree add` the currently checked out branch in case user `-g ...`'s it.
  // Git otherwise doesn't allow having one branch in two worktrees.
  const tempBranch = crypto.randomBytes(8).toString('hex')
  await exec(`git checkout -b ${tempBranch}`);

  // Make and run a separate benchmark for each version
  let results = { results: [] };
  for (const revision of revisions) {
    const versionInvocations = [`( "${revision}", ${functionName} )`]; // ( "v1.2.3", Foobar.Optimized.xyz )
    const imports = [functionName.split(".").slice(0, -1).join(".")]; // Foobar.Optimized.xyz -> Foobar.Optimized
    const templates = {
      "main.js": mainJsCode,
      "elm.json": runnerElmJsonCode,
      "src/Benchmarks.elm": runnerElmCode({
        imports,
        benchmarkName: functionName,
        args,
        versionInvocations,
      }),
    };

    // Make a temporary directory with our template files
    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), "elm-bench-"));
    tempDirs[revision] = tempDir;

    await writeTemplatesIntoTempDir({ templates, tempDir });

    const checkedOutDir = path.join(tempDir, "checked-out");
    await fs.mkdir(checkedOutDir, { recursive: true });

    // Check out the revision into the tempDir
    try {
      await exec(`git worktree add ${checkedOutDir} ${revision}`);
    } catch (e) {
      console.error(red(`Failed to check out revision: ${revision}`));
      process.exit(1);
    }

    // Combine the existing elm.json dependencies with the runner ones
    const projectDirs = [tempDir, checkedOutDir];
    const combinedDependencies = await combineElmJsonDependencies({
      projectDirs,
    });

    const checkedOutElmJsonPath = path.join(checkedOutDir, "elm.json");
    const checkedOutElmJson = JSON.parse(await fs.readFile(checkedOutElmJsonPath, "utf-8"));
    const checkedOutSrcDirs = checkedOutElmJson["source-directories"] ?? ["src"];

    const tempElmJsonPath = path.join(tempDir, "elm.json");
    const tempElmJson = JSON.parse(await fs.readFile(tempElmJsonPath, "utf-8"));
    tempElmJson.dependencies = combinedDependencies;
    if (
      !(
        tempElmJson["source-directories"].includes("src") ||
        tempElmJson["source-directories"].includes("src/")
      )
    ) {
      tempElmJson["source-directories"].push("src");
    }
    for (const srcDir of checkedOutSrcDirs) {
      tempElmJson["source-directories"].push(path.join("checked-out", srcDir));
    }

    await fs.writeFile(
      tempElmJsonPath,
      JSON.stringify(tempElmJson, null, 4),
      "utf-8"
    );

    // Compile and run everything!
    await runElmMake({
      cwd: tempDir,
      file: path.join("src", "Benchmarks.elm"),
    });
    const versionResults = await runGeneratedProgram({ tempDir });
    results.results = [...results.results, ...versionResults.results];

    if (!keep) {
      // Clean up the tempDir
      const {stderr} = await exec(`git worktree remove ${checkedOutDir}`);
      if (stderr && stderr.length > 0) {
        console.error(red(`Failed to clean git worktree for revision: ${revision}`));
        console.error(stderr);
        process.exit(1);
      }

      await removeTempFiles({ tempDir });
    }
  }

  // Check out the original git branch and remove the temporary one
  await exec(`git checkout ${originalBranch}`);
  await exec(`git branch -D ${tempBranch}`);

  if (stopSpinner) {
    stopSpinner();
  }
  if (json) {
    printJsonResults({ results, cases: revisions, keep, tempDirs });
  } else {
    printResults({ results, cases: revisions });
    if (keep) {
      console.log("\nBenchmark code is in the following directories:");
      for (const [version, tempDir] of Object.entries(tempDirs)) {
        console.log(`- ${version}: ${blue(tempDir)}`);
      }
    }
  }
}

// HELPERS

function printResults({ results, cases }) {
  /* Example of `results`:

    {
      "results": [
        { "name": [ "remove", "listRemoveOld" ], "nsPerRun": 316.43958596194926 },
        { "name": [ "remove", "listRemoveNew" ], "nsPerRun": 254.48914830045732 }
      ],
      "warning": null
    }

  Output:

    old   ████████████████████   316 ns/run   baseline
    new   ████████████████       254 ns/run   20% faster

  */

  const baseline = results.results[0].nsPerRun;
  const maxNameLength = Math.max(...cases.map((v) => v.length));
  const maxBarLength = 20;

  const fastestIndex = results.results.reduce(
    (minIndex, result, currentIndex, array) => {
      return result.nsPerRun < array[minIndex].nsPerRun
        ? currentIndex
        : minIndex;
    },
    0
  );

  process.stdout.write("\r \r\n");

  results.results.forEach((result, index) => {
    const { nsPerRun } = result;
    const case_ = cases[index];
    const barLength = Math.round((nsPerRun / baseline) * maxBarLength);
    const bar = "█".repeat(barLength);
    const nsRounded = Math.round(nsPerRun);
    const padding = " ".repeat(maxNameLength - case_.length);
    const isFastest = index === fastestIndex;

    let comparison = "";
    if (index === 0) {
      comparison = "baseline";
    } else {
      const percentDiff = Math.round((nsPerRun / baseline - 1) * 100);
      if (percentDiff > 0) {
        comparison = `${percentDiff}% slower`;
      } else if (percentDiff < 0) {
        comparison = `${Math.abs(percentDiff)}% faster`;
      } else {
        comparison = "same speed";
      }
    }

    const caseC = isFastest ? green(case_) : case_;
    const comparisonC = isFastest ? green(comparison) : comparison;

    console.log(
      `  ${caseC}${padding}   ${bar.padEnd(
        maxBarLength
      )}   ${nsRounded} ns/run   ${comparisonC}`
    );
  });

  if (results.warning) {
    console.warn("\nWarning:", results.warning);
  }
}

async function removeTempFiles({ tempDir }) {
  await fs.rm(tempDir, { recursive: true });
}

function warnAboutNoArgs({ functionName }) {
  console.error(
    red(
      "No arguments. This will make the benchmark meaningless (the benchmarked function is precomputed and benchmarks will take no time). Please make the function"
    ) +
      (functionName == null ? "s" : " " + blue(functionName)) +
      red(" take an ") +
      blue("()") +
      red(" argument and pass it here.")
  );
  usage();
  process.exit(1);
}

async function combineElmJsonDependencies({ projectDirs }) {
  const acc = { direct: {}, indirect: {} };

  for (const project of projectDirs) {
    const elmJsonPath = path.join(project, "elm.json");
    const elmJson = JSON.parse(await fs.readFile(elmJsonPath, "utf-8"));

    if (elmJson.type === "application") {
      for (const depType of ["direct", "indirect"]) {
        for (const [pkg, ver] of Object.entries(elmJson.dependencies[depType])) {
          if (
            // not in the acc yet
            !acc[depType][pkg] ||
            // higher version than the one in acc
            semverGt(ver, acc[depType][pkg])
          ) {
            // put it into acc
            acc[depType][pkg] = ver;
          }
        }
      }
    } else if (elmJson.type === "package") {
      for (const [pkg, constraint] of Object.entries(elmJson.dependencies)) {
        const lowerBound = constraint.split(" ")[0];
        if (
          // not in the acc yet
          !acc.direct[pkg] ||
          // higher version than the one in acc
          semverGt(lowerBound, acc.direct[pkg])
        ) {
          // put it into acc
          acc.direct[pkg] = lowerBound;
        }
      }
    }
  }

  // Cleanup acc: if in both direct and indirect, merge into direct and remove from indirect
  for (const [pkg, ver] of Object.entries(acc.indirect)) {
    if (pkg in acc.direct) {
      if (semverGt(ver, acc.direct[pkg])) {
        acc.direct[pkg] = ver;
      }
      delete acc.indirect[pkg];
    }
  }

  return acc;
}

async function runElmMake({ file, cwd }) {
  const elmMakeCommand = `${elmCompiler} make ${file} --optimize --output elm.js`;
  const { stderr } = await exec(elmMakeCommand, { cwd, encoding: "utf-8" });
  if (stderr && stderr.length > 0) {
    if (stderr) {
      console.error("Elm make errors:");
      console.error(stderr);
    }
  }
}

async function findElmFiles(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = await Promise.all(
    entries.map((entry) => {
      const res = path.resolve(dir, entry.name);
      return entry.isDirectory() ? findElmFiles(res) : res;
    })
  );
  return files.flat().filter((file) => file.endsWith(".elm"));
}

async function runGeneratedProgram({ tempDir }) {
  const nodeCommand = "node main.js";
  const { stdout, stderr } = await exec(nodeCommand, {
    cwd: tempDir,
    encoding: "utf-8",
  });
  if (stderr && stderr.length > 0) {
    console.error("Node execution errors:");
    console.error(stderr);
  }

  const results = JSON.parse(stdout);
  return results;
}

function runnerElmCode({ imports, benchmarkName, args, versionInvocations }) {
  const importsCode = imports.map((imp) => `import ${imp}`).join("\n");
  const argsCode = args.map((_, i) => `arg${i}`).join(" ");
  const argDefsCode = args
    .map((arg, i) => `arg${i} =\n    ${arg}`)
    .join("\n\n\n");
  const versionsCode = `[ ${versionInvocations.join("\n        , ")}
        ]`;

  return `port module Benchmarks exposing (main)

import Benchmark exposing (Benchmark)
import Benchmark.Alternative
import Benchmark.Runner.Cli
${importsCode}


port sendOutput : Benchmark.Runner.Cli.Output -> Cmd msg


main =
    Benchmark.Runner.Cli.program
        { suite = suite
        , sendOutput = sendOutput
        }


suite : Benchmark
suite =
    Benchmark.Alternative.rank
        "${benchmarkName}"
        (\\f -> f ${argsCode})
        ${versionsCode}


${argDefsCode}`;
}

async function writeTemplatesIntoTempDir({ templates, tempDir }) {
  // Write out the templates to the temporary directory
  for (const [fileName, content] of Object.entries(templates)) {
    const filePath = path.join(tempDir, fileName);
    const dirPath = path.dirname(filePath);

    // Ensure the directory exists
    await fs.mkdir(dirPath, { recursive: true });

    // Write the file
    await fs.writeFile(filePath, content, "utf-8");
  }
}

async function copyElmProject(src, dest) {
  // Read the "source-directories" from the elm.json file
  const elmJsonPath = path.join(src, "elm.json");
  const elmJson = JSON.parse(await fs.readFile(elmJsonPath, "utf-8"));
  const sourceDirs = elmJson["source-directories"] ?? ["src"];

  // Copy each source directory
  for (const sourceDir of sourceDirs) {
    const sourcePath = path.join(src, sourceDir);
    const destPath = path.join(dest, sourceDir);
    await copyRecursiveElm(sourcePath, destPath);
  }
}

async function copyRecursiveElm(src, dest) {
  const stats = await fs.stat(src);
  if (stats.isDirectory()) {
    // If it's a directory, create it in the destination and copy its contents
    await fs.mkdir(dest, { recursive: true });
    const entries = await fs.readdir(src);
    for (const entry of entries) {
      await copyRecursiveElm(path.join(src, entry), path.join(dest, entry));
    }
  } else {
    // If it's a file, copy it directly
    if (src.endsWith(".elm")) {
      await fs.copyFile(src, dest);
    }
  }
}

function printJsonResults({ results, cases, keep, tempDirs }) {
  /* Example of `results`:

    {
      "results": [
        { "name": [ "remove", "listRemoveOld" ], "nsPerRun": 316.43958596194926 },
        { "name": [ "remove", "listRemoveNew" ], "nsPerRun": 254.48914830045732 }
      ],
      "warning": null
    }

  Output:

    [ 
      { "name": "old", "nsPerRun": 316.43958596194926, "benchmarkDir": "/tmp/elm-bench-old", "warning": null },
      { "name": "new", "nsPerRun": 254.48914830045732, "benchmarkDir": "/tmp/elm-bench-new", "warning": null }
    ]

  */
  const json = results.results.map((result, i) => ({
    name: cases[i],
    nsPerRun: result.nsPerRun,
    benchmarkDir: keep ? tempDirs[cases[i]] : null,
    warning: results.warning ?? null,
  }));
  process.stdout.write(JSON.stringify(json, null, 2) + "\n");
}
